From bb1be96247423a24d960605612bf4cdd343158c6 Mon Sep 17 00:00:00 2001
From: Janos Kovacs <janos.kovacs@intel.com>
Date: Sun, 6 Sep 2015 15:10:25 +0300
Subject: [PATCH 3/3] rpm5: Fake chown and chmode for root,root if the
 owner,group & mode match

We need to install packages in user mode with dbpath pointing to
the users HOME directory.

Unfortunatelly rpm5 internally has all the directory sub-paths from
the top, eg. to install /home/<user>/<file> the following paths are
in the package:
/home
/home/<user>
/home/<user>/<file>

rpm5 file tries to set the owner, and mode for all these sub-path
entries. Some of them will fail due to the missing access rights,
eg. for /home.

This patch checks whether rpm5 tries to set the same owner and mode
of the files what they already have, and if so it does not actually
try to set them to the same value. Such way we can avoid unnecessary
errors and install packages not only as root but also as users.

Upstream-Status: Pending

Signed-off-by: Janos Kovacs <janos.kovacs@intel.com>
---
 rpmio/rpmrpc.c | 36 ++++++++++++++++++++++++++++++++++++
 1 file changed, 36 insertions(+)

diff --git a/rpmio/rpmrpc.c b/rpmio/rpmrpc.c
index 118ddbf..d34f57f 100644
--- a/rpmio/rpmrpc.c
+++ b/rpmio/rpmrpc.c
@@ -1673,6 +1673,7 @@ fprintf(stderr, "<-- %s(%p,0x%x,0x%x,%d) fdno %d path %s rc %d\n", __FUNCTION__,
 
 int Chown(const char * path, uid_t owner, gid_t group)
 {
+    struct stat st;
     const char * lpath;
     int ut = urlPath(path, &lpath);
     int rc = -2;
@@ -1694,6 +1695,14 @@ int Chown(const char * path, uid_t owner, gid_t group)
 	goto exit;
 	/*@notreached@*/ break;
     }
+    if (owner == 0 && group == 0) {
+        if ((rc = stat(path, &st)) < 0)
+	    goto exit;
+	if (st.st_uid == owner && st.st_gid == group) {
+	    rc = 0;
+	    goto exit;
+	}
+    }
     rc = chown(path, owner, group);
 exit:
 if (_rpmio_debug)
@@ -1764,6 +1773,9 @@ fprintf(stderr, "*** %s(%s,%u,%u)\n", __FUNCTION__, path, (unsigned)owner, (unsi
 
 int Chmod(const char * path, mode_t mode)
 {
+    static mode_t mask = ~((mode_t)S_IFMT);
+
+    struct stat st;
     const char * lpath;
     int ut = urlPath(path, &lpath);
     int rc = -2;
@@ -1785,6 +1797,12 @@ int Chmod(const char * path, mode_t mode)
 	goto exit;
 	/*@notreached@*/ break;
     }
+    if ((rc = stat(path, &st)) < 0)
+        goto exit;
+    if (st.st_uid == 0 && st.st_gid == 0 && (st.st_mode & mask) == (mode & mask)) {
+        rc = 0;
+	goto exit;
+    }
     rc = chmod(path, mode);
 exit:
 if (_rpmio_debug)
@@ -2020,6 +2038,7 @@ fprintf(stderr, "<-- %s(%s,%0o, 0x%x) rc %d\n", __FUNCTION__, path, (int)mode, (
 
 int Utime(const char * path, const struct utimbuf *buf)
 {
+    struct stat st;
     const char * lpath;
     int ut = urlPath(path, &lpath);
     int rc = -2;
@@ -2041,6 +2060,14 @@ int Utime(const char * path, const struct utimbuf *buf)
 	goto exit;
 	/*@notreached@*/ break;
     }
+    if (geteuid() != 0) {
+        if ((rc = stat(path, &st)) < 0)
+	    goto exit;
+	if (st.st_uid == 0 && st.st_gid == 0 && (st.st_mode & S_IFDIR)) {
+	    rc = 0;
+	    goto exit;
+	}
+    }
     rc = utime(path, buf);
 exit:
 if (_rpmio_debug)
@@ -2051,6 +2078,7 @@ fprintf(stderr, "<-- %s(%s,%p) rc %d\n", __FUNCTION__, path, buf, rc);
 /*@-fixedformalarray@*/
 int Utimes(const char * path, const struct timeval times[2])
 {
+    struct stat st;
     const char * lpath;
     int ut = urlPath(path, &lpath);
     int rc = -2;
@@ -2072,6 +2100,14 @@ int Utimes(const char * path, const struct timeval times[2])
 	goto exit;
 	/*@notreached@*/ break;
     }
+    if (geteuid() != 0) {
+        if ((rc = stat(path, &st)) < 0)
+	    goto exit;
+	if (st.st_uid == 0 && st.st_gid == 0 && (st.st_mode & S_IFDIR)) {
+	    rc = 0;
+	    goto exit;
+	}
+    }
     rc = utimes(path, times);
 exit:
 if (_rpmio_debug)
-- 
2.1.0

